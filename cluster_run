#!/usr/bin/env python
import os, subprocess, sys, signal, termios, atexit, socket, getopt

def testament_child_death():
    rv = os.fork()
    if rv == 0:
        os.kill(os.getpid(), signal.SIGSTOP)
        os._exit(0)
    os.waitpid(rv, os.WUNTRACED)

PREFIX = subprocess.Popen(". $(pwd)/.configuration && echo $prefix", shell = True, stdout=subprocess.PIPE).communicate()[0].rstrip()

base_direct_port = 12000
base_api_port = 9000
base_couch_port = 9500
base_mccouch_port = 13000


def setup_path():
    def ebin_search(path):
        return subprocess.Popen(["find", path, "-name", "ebin", "-type", "d"],
                                stdout=subprocess.PIPE).communicate()[0].split()

    path = ebin_search(".")
    couchpath = ebin_search("{0}/lib/couchdb/erlang/lib".format(PREFIX))
    couch_plugins = ebin_search("{0}/lib/couchdb/plugins".format(PREFIX))

    if len(couchpath) == 0:
       print("Couch libs wasn't found. Will disable couch support\n")
       os.environ['DONT_START_COUCH'] = '1'

    return couchpath + path + couch_plugins

def mk_node_couch_config(i):
    try:
        os.mkdir("couch")
    except os.error:
        pass

    with open("couch/n_{0}_conf.ini".format(i), "w") as f:
        f.write("[httpd]\n")
        f.write("port={0}\n".format(base_couch_port + i))
        f.write("[couchdb]\n")
        f.write("database_dir={0}/couch/{1}\n".format(os.getcwd(), i))
        f.write("view_index_dir={0}/couch/{1}\n".format(os.getcwd(), i))
        f.write("max_dbs_open=10000\n")
        f.write("[log]\n")
        f.write("file={0}/couch/{1}.log\n".format(os.getcwd(), i))
        f.write("[daemons]\n")
        f.write("mc_daemon={{mc_sup, start_link, [{0}]}}\n".format(base_mccouch_port+i))

def couch_configs(i):
    mk_node_couch_config(i)
    return ["{0}/etc/couchdb/default.ini".format(PREFIX),
            "{0}/etc/couchdb/default.d/capi.ini".format(PREFIX),
            "{0}/etc/couchdb/local.d/geocouch.ini".format(PREFIX),
            "couch/n_{0}_conf.ini".format(i)]

class Node(object):
    ebin_path = setup_path()

    def __init__(self, ix, host, extra_args):
        self._ix         = ix
        self._host       = host
        self._extra_args = extra_args

        self._process = None

        self._start_node()

    def _start_node(self):
        logdir = "logs/n_{0}".format(self._ix)
        try:
            os.makedirs(logdir)
        except:
            pass

        try:
            os.stat("data/n_{0}/mnesia".format(self._ix))
        except:
            os.makedirs("data/n_{0}/mnesia".format(self._ix))

        args = ["erl", "+A", "16", "-pa"] + self.ebin_path + [
            # disables Ctrl-C handler
            "+B", "i",
            "-setcookie", "nocookie",
            "-name", "n_{0}@{1}".format(self._ix, self._host),
            "-kernel", "inet_dist_listen_min", "21100",
            "inet_dist_listen_max", "21199",
            "-couch_ini"] + couch_configs(self._ix) + [
            "-ns_server", "config_path", '"etc/static_config.in"',
            "-ns_server", "nodefile", '"data/n_{0}/node"'.format(self._ix),
            "-ns_server", "cookiefile", '"data/n_{0}/cookie"'.format(self._ix),
            "error_logger_mf_dir", '"{0}"'.format(logdir),
            "error_logger_mf_maxbytes", "10485760",
            "error_logger_mf_maxfiles", "10",
            "dont_suppress_stderr_logger", "true",
            "path_config_etcdir", '"priv"',
            "path_config_bindir", '"{0}"'.format(PREFIX+"/bin"),
            "path_config_libdir", '"{0}"'.format(PREFIX+"/lib"),
            "path_config_datadir", '"data/n_{0}"'.format(self._ix),
            "path_config_tmpdir", '"tmp/"',
            "rest_port", str(base_api_port + self._ix),
            "memcached_port", str(base_direct_port + self._ix * 2),
            "mccouch_port", str(base_mccouch_port + self._ix),
            "moxi_port", str(base_direct_port + self._ix * 2 + 1),
            "short_name", '"n_{0}"'.format(self._ix)
            ] + self._extra_args

        # attempt to prevent erl from terminating on SIGHUP
        def preexec():
            signal.signal(signal.SIGHUP, signal.SIG_IGN)

        if self._ix == 0:
            self._process = subprocess.Popen(args,
                                             preexec_fn=preexec)
        else:
            self._process = \
                subprocess.Popen(args + ["-noshell"],
                                 stdin=subprocess.PIPE,
                                 preexec_fn=preexec)

    def kill(self):
        if self._process is not None:
            data_dir = "data/n_{0}".format(self._ix)
            cookie_path = os.path.join(data_dir, "cookie")
            node_path   = os.path.join(data_dir, "node")

            with open(cookie_path, "r") as f:
                cookie = f.read().strip()

            with open(node_path, "r") as f:
                node = f.read().strip()

            erl_cmd = \
                "rpc:call('{0}', ns_bootstrap, stop, []), init:stop().".format(node)

            subprocess.Popen(["erl",
                              "-name", "executioner_{0}".format(self._ix),
                              "-noshell",
                              "-hidden",
                              "-setcookie", cookie,
                              "-eval", erl_cmd])

    def wait(self):
        if self._process is not None:
            self._process.wait()

def start_cluster(num_nodes, start_index, host, extra_args):
    return [Node(i + start_index, host, extra_args) for i in xrange(num_nodes)]

def usage():
    sys.exit("Usage: {0} [--nodes=N] [--dont-rename] [--dont-start] [--interactive] [--static-cookie] [ns_server args]".format(sys.argv[0]))

def maybe_spawn_epmd():
    try:
        socket.create_connection(("127.0.0.1", 4369)).close()
    except socket.error:
        print("Spawning epmd...\n")
        subprocess.Popen("erl -noshell -setcookie nocookie -sname init -run init stop 2>&1 > /dev/null",
                         shell = True).communicate()

def find_primary_addr():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 56))
        addr, port = s.getsockname()
        return addr
    except socket.error:
        return None
    finally:
        s.close()

def main():
    try:
        optlist, args = getopt.gnu_getopt(sys.argv[1:], "hn:i", ["help", "start-index=", "nodes=", "interactive", "static-cookie", "dont-start", "host="])
    except getopt.GetoptError, err:
        # print help information and exit:
        print str(err) # will print something like "option -a not recognized"
        usage()
        sys.exit(2)

    primary_addr = find_primary_addr()

    dont_start = False
    static_cookie = False
    interactive_shell = False
    start_index = 0
    num_nodes = 1
    host = "127.0.0.1" if primary_addr == None else primary_addr

    for o, a in optlist:
        if o in ("--nodes", "-n"):
            num_nodes = int(a)
        elif o in ("--interactive", "-i"):
            interactive_shell = True
        elif o == '--dont-start':
            dont_start = True
        elif o == '--host':
            host = a
        elif o == '--start-index':
            start_index = int(a)
        elif o in ("--help", "-h"):
            usage()
            exit(0)
        elif o in("--static-cookie"):
            static_cookie = True
        else:
            assert False, "unhandled options"

    nodes = []
    terminal_attrs = None

    def kill_nodes(signum, trace):
        for n in nodes:
            try:
                n.kill()
                n.wait()
            except OSError:
                pass

        if terminal_attrs != None:
            termios.tcsetattr(sys.stdin, termios.TCSANOW, terminal_attrs)

        sys.exit(0)

    signal.signal(signal.SIGHUP,  kill_nodes)
    signal.signal(signal.SIGINT,  kill_nodes)
    signal.signal(signal.SIGTERM, kill_nodes)

    testament_child_death()

    try:
        terminal_attrs = termios.tcgetattr(sys.stdin)
    except:
        pass

    maybe_spawn_epmd()

    extra_args = args[1:]

    if static_cookie:
        extra_args += ["-ns_server", "dont_reset_cookie", "true"]

    if not dont_start:
        extra_args += ["-run", "ns_bootstrap"]

    if not interactive_shell:
        extra_args += ["-noinput"]

    nodes = start_cluster(num_nodes, start_index, host, extra_args)

    for node in nodes:
        node.wait()


if __name__ == '__main__':
    main()
